#+TITLE: Emacs Configuration

* Global Settings

** Automatically load changes from the disk

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC

** Fix colorspace for OSX

#+BEGIN_SRC emacs-lisp
(setq ns-use-srgb-colorspace nil)
#+END_SRC

** Ask y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Hide the usual startup message

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)
#+END_SRC

** Use the visual bell instead of the terminal bell

#+BEGIN_SRC emacs-lisp
(setq visual-bell t)
#+END_SRC

** Pick up the correct PATH on OSX and Linux

#+BEGIN_SRC emacs-lisp
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+END_SRC
* Vim Key Bindings

Emacs is an amazing work environment, but I can't get by without Vim key
bindings. This section has only the most basic setup and window navigation
settings. Key bindings that are related to specific modes will be located
with that mode's configuration.

** The Basics
   
Get the basics up and running: evil, support for key chords (so insert mode can
be exited with =jj=, among other things), and support for a leader key.

#+BEGIN_SRC emacs-lisp
(use-package evil :ensure t :pin melpa-stable)
(use-package evil-leader :ensure t :pin melpa-stable)

(evil-mode 1)
(global-evil-leader-mode)
(evil-leader/set-leader ",")

(key-chord-mode 1)
(setq key-chord-two-key-delay 0.7)
(setq key-chord-one-key-delay 1.0)
(key-chord-define evil-insert-state-map "pf" 'evil-normal-state)
#+END_SRC

** Window Navigation

Key mapping for manipulating windows and frames.

| Command | Action                                                         |
|---------+----------------------------------------------------------------|
| =vv=    | Split the current window into two vertically stacked windows   |
| =ss=    | Split the current window into two horizontally stacked windows |
| =,1=    | Close all windows except for the current one                   |
| =,v=    | Close all windows in the current vertical split                |
| =,q=    | Save and close the current window                              |
| =C-h=   | Navigate to the window left of the current window              |
| =C-l=   | Navigate to the window right of the current window             |
| =C-k=   | Navigate to the window above of the current window             |
| =C-j=   | Navigate to the window below of the current window             |
| =,m=    | Maximized the current frame                                    |
| =,f=    | Toggle fullscreen for the current frame                        |

#+BEGIN_SRC emacs-lisp
(eval-after-load "evil"
  '(progn
    (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
    (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
    (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
    (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
    (define-key evil-emacs-state-map (kbd "C-h") 'evil-window-left)
    (define-key evil-emacs-state-map (kbd "C-j") 'evil-window-down)
    (define-key evil-emacs-state-map (kbd "C-k") 'evil-window-up)
    (define-key evil-emacs-state-map (kbd "C-l") 'evil-window-right)))

(key-chord-define evil-normal-state-map "vv" 'split-window-horizontally)
(key-chord-define evil-normal-state-map "ss" 'split-window-vertically)
(key-chord-define evil-emacs-state-map "vv" 'split-window-horizontally)

(evil-leader/set-key
  "m" 'toggle-frame-maximized
  "f" 'toggle-frame-fullscreen
  "v" 'delete-other-windows-vertically
  "1" 'delete-other-windows
  "q" 'evil-save-and-close)
#+END_SRC

* Code Settings

** Enable syntax highlighting

#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

** Show line numbers

By defaut, show line numbers everywhere. However, disable them in a few places
where they are either unnecessary or where they cause performance issues.

#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
(setq line-number-mode t)
(setq column-number-mode t)
(setq linum-format "%4d ")

(defun nolinum ()
  (linum-mode 0))

(add-hook 'org-mode-hook 'nolinum)
(add-hook 'shell-mode-hook 'nolinum)
(add-hook 'ansi-term-hook 'nolinum)
(add-hook 'term-mode-hook 'nolinum)
#+END_SRC

** Use spaces instead of tabs

I like 2 spaces as default indent.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq default-tab-width 2)
(setq tab-width 2)
#+END_SRC

** Visually indicate matching pairs of parenthesis

#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(setq show-paren-delay 0.0)
#+END_SRC

* Status Bar

This section contains all the configuration for the status bar.

** Hide some minor modes

There are a group of packages that will automatically be loaded, but we want to
be diminished (meaning that they won't appear in the modeline).

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :init (global-undo-tree-mode))

(diminish 'auto-revert-mode)
(eval-after-load 'auto-revert-mode
  '(diminish 'auto-revert-mode))
#+END_SRC

* Theming

Emacs is an incredibly flexible piece of software that can display a lot of
different information and adapt itself to both the terminal and the GUI.
Unfortunately, it's a bit ugly on its own. This is my attempt to prettify.

** Window Customizations

My preference is to interact through the keyboard, so hide unnecessary window
chrome.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
(menu-bar-mode -1)

(if (display-graphic-p)
  (scroll-bar-mode -1))
#+END_SRC

** Set the font face

My current flavor of the moment in terms of font face is Operator Mono. While
it doesn't have some nice features like ligatures, it is well structured and
has features like cursive for italics, which give great visibility for
different parts of the code.

In addition to setting the default font face, configure italics and set a
couple custom typefaces.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(font . "Fira Code-12"))

(let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
               (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
               (36 . ".\\(?:>\\)")
               (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
               (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
               (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
               (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
               (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
               (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
               (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
               (48 . ".\\(?:x[a-zA-Z]\\)")
               (58 . ".\\(?:::\\|[:=]\\)")
               (59 . ".\\(?:;;\\|;\\)")
               (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
               (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
               (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
               (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
               (91 . ".\\(?:]\\)")
               (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
               (94 . ".\\(?:=\\)")
               (119 . ".\\(?:ww\\)")
               (123 . ".\\(?:-\\)")
               (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
               (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
               )
             ))
  (dolist (char-regexp alist)
    (set-char-table-range composition-function-table (car char-regexp)
                          `([,(cdr char-regexp) 0 font-shape-gstring]))))
#+END_SRC

** Add an icon font

At various points, an icon font will be used to convey information. Make
sure that it's available.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons :ensure t :pin melpa-stable)
(require 'all-the-icons)
#+END_SRC

** Color scheme

#+BEGIN_SRC emacs-lisp
(use-package dracula-theme :ensure t :pin melpa-stable)
(load-theme 'dracula)
#+END_SRC

* File and Buffer Navigation

This configuration supports navigating the environment by using fuzzy matching
and a project-tree. Both work inside of source control and also support custom
buffer matching.

| Command | Action                   |
|---------+--------------------------|
| =,b=    | View all open buffers    |
| =,t=    | Open fuzzy matching pane |
| =C-n=   | Open file browser        |

** Fuzzy Matching

Helm and Projectile are used for fuzzy matching when searching for files and
navigating menus.

#+begin_src emacs-lisp
(use-package projectile :ensure t :pin melpa-stable)
(use-package helm :ensure t :pin melpa-stable)

(projectile-global-mode)
(require 'helm-config)

(setq projectile-keymap-prefix (kbd "C-c p"))

(evil-leader/set-key "t" 'helm-projectile)
#+end_src

** Tree View

Visually, I find that I need a tree to keep everything organized in my mind,
especially for large projects.

After using Atom for a while, I've become partial to some of it's fancy icon UI
to identify folder types. So, the =all-the-icons= package is being installed to
give us a little icon candy.

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :ensure t
  :pin melpa-stable)

(setq neo-autorefresh nil)

(use-package all-the-icons
  :ensure t
  :pin melpa-stable)

(require 'neotree)
(require 'all-the-icons)

(setq neo-theme (if (display-graphic-p) 'icons 'arrow))

(defun neotree-project-dir ()
    "Open NeoTree using the git root."
    (interactive)
    (let ((project-dir (projectile-project-root))
          (file-name (buffer-file-name)))
      (neotree-toggle)
      (if project-dir
          (if (neo-global--window-exists-p)
              (progn
                (neotree-dir project-dir)
                (neotree-find file-name)))
        (message "Could not find git project root."))))

(eval-after-load "evil"
  '(progn
    (define-key evil-normal-state-map (kbd "C-n") 'neotree-project-dir)))

 (add-hook 'neotree-mode-hook
    (lambda ()
        (define-key evil-normal-state-local-map (kbd "TAB") 'neotree-enter)
        (define-key evil-normal-state-local-map (kbd "SPC") 'neotree-enter)
        (define-key evil-normal-state-local-map (kbd "q") 'neotree-hide)
        (define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter)))
#+END_SRC

** Buffers

Use the much superior =iBuffer= to navigation the buffer list.

#+BEGIN_SRC emacs-lisp
(require 'ibuffer)
(global-set-key (kbd "C-x C-b") 'ibuffer)
(setq ibuffer-default-sorting-mode 'major-mode)

(evil-leader/set-key "b" 'ibuffer)
(setq-default dired-listing-switches "-alh")
#+END_SRC

* Git
** Magit

So, magit is basically the best git plugin available. Let's configure some
key commands.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :pin melpa-stable)

(global-set-key (kbd "C-x g") 'magit-status)
(evil-leader/set-key "g" 'magit-status)
#+END_SRC

** Git Gutter

#+BEGIN_SRC
(use-package git-gutter
  :ensure t
  :pin melpa-stable)

(global-git-gutter-mode +1)
#+END_SRC
* Org Mode
** Task States

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
    '((sequence "TODO" "IN-PROGRESS" "BLOCKED" "|" "DONE" "CANCELED")))
#+END_SRC

** Completion Details

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

** Export Markdown

#+BEGIN_SRC emacs-lisp
(eval-after-load "org"
  '(require 'ox-md nil t))
#+END_SRC

** Bullet Points

I like sexy looking bullets rather than just having a trail of ASCII stars.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :pin melpa-stable)

(require 'org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

* Language Configuration
** Global Settings
*** Commenting Code

I love tpope's awesome vim-commentary plugin for Vim. Bringing over the
behavior to emacs (via evil).

#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :diminish evil-commentary-mode
  :ensure t
  :pin melpa-stable)

(evil-commentary-mode)
#+END_SRC

*** Linting

Use =flycheck= to give us inline type checking.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "/usr/local/bin/multimarkdown"))
#+END_SRC

** Scala
*** Ensime

Use Ensime to provide syntax highlighting, indentation, refactoring support,
completion of symbols, etc.

#+BEGIN_SRC emacs-lisp
(setq exec-path (append exec-path '("/usr/local/bin")))
(setq exec-path (append exec-path '("/usr/local/sbin")))
(setenv "PATH" (shell-command-to-string "/bin/bash -c 'echo -n $PATH'"))

(use-package ensime :ensure t :pin melpa)
(use-package sbt-mode :pin melpa)
(use-package scala-mode :pin melpa)
#+END_SRC

*** Custom Key Bindings

#+begin_src emacs-lisp
(add-hook 'ensime-mode-hook (lambda ()
  (evil-leader/set-key "d" 'ensime-edit-definition)
  (evil-leader/set-key "c" 'ensime-sbt-do-compile)
  (evil-leader/set-key "h" 'ensime-sbt-do-test)))
#+end_src

** JavaScript
*** web-mode

web-mode is used to parse JavaScript and JSX files.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :pin melpa-stable)

(require 'web-mode)

(add-to-list 'auto-mode-alist
  '("\\.js[x]?\\'" . web-mode))

(setq web-mode-content-types-alist
  '(("jsx" . "\\.js[x]?\\'")))
#+END_SRC

*** Default style settings

#+BEGIN_SRC emacs-lisp
(setq web-mode-markup-indent-offset 2)
(setq web-mode-css-indent-offset 2)
(setq web-mode-code-indent-offset 2)
(setq web-mode-attr-indent-offset 2)
(setq web-mode-enable-auto-quoting nil)
#+END_SRC

** GoLang
*** Install go-mode

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :ensure t
  :pin melpa-stable)

(use-package exec-path-from-shell
  :ensure t
  :pin melpa-stable)

(setenv "GOPATH" "/home/jeff/go")
(add-to-list 'exec-path "/home/jeff/go/bin")
#+END_SRC

*** Compile and test

Define a couple commands for compiling and testing generic Go projects.

For compile: =go build -v && go vet=

#+BEGIN_SRC emacs-lisp
(use-package gotest
  :ensure t
  :pin melpa-stable)

(defun go-compile-hook ()
  (if (not (string-match "go" compile-command))
      (set (make-local-variable 'compile-command)
           "go build -v && go vet")))

(add-hook 'go-mode-hook 'go-compile-hook)
#+END_SRC

*** Format on Save

#+BEGIN_SRC emacs-lisp
(setq gofmt-command "goimports")
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

*** Custom Key Bindings

#+BEGIN_SRC emacs-lisp
(add-hook 'go-mode-hook (lambda()
  (evil-leader/set-key "c" 'compile)
  (evil-leader/set-key "h" 'go-test-current-project)
  (key-chord-define evil-normal-state-map "gd" 'godef-jump)))
#+END_SRC
